<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<meta name="description" content="The description goes here">
	<meta name="keywords" content="JavaScript">
	<meta name="author" content="Aigars">
	<title>Misc</title>
</head>
<body>


</body>

<script type="text/javascript">
/*	


//14
function dilstosaVirkne(a) {
	var virkne = [];
	if (a <=0) {
		return "Ievadīta neatļauta vērtība";
	} else

	for (var x=a; x>0;x--) {
		virkne.push(x);
	}
	return virkne;
}

console.log(dilstosaVirkne(-1));


Dotajai nedēļas dienai (apzīmēta kā P, O, T, C, Pk, Se, Sv) un pazīmei, vai mēs esam atvaļinājumā, atgrieziet laiku, cikos būtu jāzvana modinātājam. Darbadienās modinātājam jāzvana 7:00, bet brīvdienās 10:00, bet, ja mēs esam atvaļinājumā, tad darbadienās modinātājam jāzvana 10:00, bet brīvdienās jābūt izslēgtam.

modinatajs(“P”, false) → "7:00"
modinatajs (“Pk”, false) → "7:00"
modinatajs (“Se”, true) → "Off"

//15

function modinatajs(a,b) {
	if (!b) {
	switch (a) {
		case "P":
		case "O":
		case "T":
		case "C":
		case "Pk":
			return "7:00";
			break;
		case "Se":
		case "Sv":
			return "10:00";
			break;
	}
} else {
		switch (a) {
		case "P":
		case "O":
		case "T":
		case "C":
		case "Pk":
			return "10:00";
			break;
		case "Se":
		case "Sv":
			return "off";
			break;

		}

	} 
};

console.log(modinatajs("P", false));

Jūs braucat pārsniedzot atļauto braukšanas ātrumu un ceļu policija jūs aptur. Uzrakstiet programmu, kas nosaka soda apmēru (0 – nav soda, 1 – neliels sods, 2 – liels sods). Ja jūsu ātrums ir 60 vai mazāk, tad nav soda. Ja ātrums ir no 61 līdz 80 ieskaitot, tad ir neliels sods. Ja ātrums pārsniedz 80, tad ir liels sods. Izņēmums ir jūsu dzimšanas dienas – kad jūsu atļautais ātrums var būt par +5 lielāks.

sodaNoteiksana(60, false) → 0
sodaNoteiksana(65, false) → 1
sodaNoteiksana(65, true) → 0




function sodaNoteiksana (a,b) {
	if (!b) {
	if  (a<=60) {
		return "0 - nav soda";
	} else if (a>60) {
		return "1 - neliels sods";
	} else if (a>80) {
		return "2 - liels sods";
	} 
}
	else 
		
		{
		if  (a<=65) {
		return "0 - nav soda";
	} else if (a>65) {
		return "1 - neliels sods";
	} else if (a>85) {
		return "2 - liels sods";
	} 
		}};

console.log(sodaNoteiksana(82, false));

//17 

Doti 2 veseli skaitļi. Atgrieziet skaitli, kurš ir tuvāk vērtībai 21 un to nepārsniedz. Atgrieziet 0, ja abas vērtības pārsniedz 21.

uzvaretajs(19, 21) → 21
uzvaretajs(20, 18) → 20
uzvaretajs(19, 22) → 19



function uzvaretajs(a,b) {
	// closer to 21. 30 ; 7 ... 9 , 7 Math.abs(number);
var num = 21;

if ((num-a<0) && (num-b<0)) {
	return 0;
} else if (a<num && b<num) {
	if (a>b) {
		return a;
	} else {
		return b;
	}
} else if (a>num || b>num) {
	if (a>b) {
		return b;
	} else {
		return a;
	}
}
};

console.log(uzvaretajs(22, 11));


Uzdevums #20 – “Fizz-Buzz”

Dota sākuma vērtība A un beigu vērtība B. Izvadiet visus naturālos skaitļus no A līdz B, bet skaitļus, kas dalās ar 3 aizvietojiet ar “Fizz”, skaitļus, kas dalās ar 5 – aizvietojiet ar “Buzz” un skaitļus, kas dalās gan ar 3, gan ar 5 – ar “FizzBuzz”.
(!) x % 5 atgriež dalījuma ar 5 atlikumu. 
     Ja “x % 5 == 0”, tad skaitlis dalās ar 5.

fizzBuzz(1, 5) → "1,2,Fizz,4,Buzz
fizzBuzz(1, 7) → "1,2,Fizz,4,Buzz,Fizz,7"



function fizzBuzz(a,b) {
	var result = [];
	for (var x=a;x<=b;x++) {
		if (x%3==0) { 
			result.push("Fizz");
		} else if (x%5==0) {
			 result.push("Buzz");
			}
		else {
			result.push(x);
		}
	}
	return result;
}

//how to get the same result with console log?

function fizzBuzz(a,b) {
	var result = "";
	for (var x=a;x<=b;x++) {
		if (x%3==0) { 
			result = "Fizz";
		} 
		else if (x%5==0) {
			 result = "Buzz";
		} else
		 result = x;
		console.log(result);
}
}

Uzdevums #21 – Skaitļu sērija

Dota vērtība N. Izvadiet skaitļus pēc parauga “1, 1, 2, 1, 2, 3, …, 1, 2, 3, …, N”.

skaitluSerija(3) → “1, 1, 2, 1, 2, 3“
skaitluSerija(4) → “1, 1, 2, 1, 2, 3, 1, 2, 3, 4“
skaitluSerija(2) → “1, 1, 2“



function skaitluSerija(a) {

//1 = 1, 2= 1,2 ...
var temp = [];
for (var x=1;x<=a; x++) {
	for (var b=1; b<=x;b++) {
		temp.push(b);
	}
}
	return temp;
}; ///works, but why?


console.log(skaitluSerija(4));




Uzdevums #22 – Karātavas
Definējiet masīvu ar vārdiem. Izvēlieties nejaušu vārdu no masīva un izvadiet lietotājam burtu skaitu vārdā. Ļaujiet lietotājam ievadīt kādu burtu un attēlojiet šo burtu atbilstošajās pozīcijās, ja tāds eksistē, vai arī samaziniet atlikušo gājienu skaitu, ja dotais burts šajā vārdā neeksistēja. Izvadiet atbilstošu paziņojumu, vai vārds tika uzminēts, vai nē.
Piemēram, izvēlēts vārds “AKA”. Sākumā lietotājam izvadiet “_ _ _”. Pēc pareizas burta ievades attēlojiet “A _ A”, bet pēc nepareizas burta ievades attēlojiet “Burts S nav šajā vārdā. Jums atlikuši 4 mēģinājumi”.
(!) int random = java.util.concurrent.ThreadLocalRandom.current().nextInt(min, max + 1);



function largestOfFour(arr) {
  var newArr =[];
  var finArr=[];
  var i = [];
  for (var x=0;x<arr.length;x++) 
  {
		newArr = arr[x];
 // 	console.log(newArr);  	
  	for (y=0;y<arr[x].length;y++) 
  	{	
		i = Math.max.apply(Math, arr[x]);

  	} 		finArr.push(i); //returns 4 values.

  }
console.log(finArr);
}

//largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]);
largestOfFour([[1000, 1001, 857, 1],[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39]]);



console.log("aigars".substr(4,6)); // rs
console.log("aigars".substring(1,2)); // i. 2nd argument starts from 1

console.log("*******************"); // i. 2nd argument starts from 1

function confirmEnding(str, target) {
	var len1 = str.length;
	var len2 = target.length;

	if (str.substr((len1-len2), len1) == target) 
	{
	console.log(true);
	}
	else console.log(false);
}

confirmEnding("Bastian", "aan");


//Repeat a given string (first argument) num times (second argument). Return an empty string if num is not a positive number.


function repeatStringNumTimes(str, num) {
  var value = "";

  for (x=1;x<=num;x++) {

	  if (num>=0) {
	  	value += str + " ";
	  } else {
	  	value = "";
	  }
   }   console.log(value);
}

repeatStringNumTimes("abc", 3);


Truncate a string (first argument) if it is longer than the given maximum string length (second argument). Return the truncated string with a ... ending.

Note that inserting the three dots to the end will add to the string length.

However, if the given maximum string length num is less than or equal to 3, then the addition of the three dots does not add to the string length in determining the truncated string.



//console.log("aigars".substr(4,6)); // rs
//console.log("aigars".substring(1,2)); // i. 2nd argument starts from 1

function truncateString(str, num) {
  // Clear out that junk in your trunk
	if (str.length>num) 
	{
		if (num>=3) 
		{
			console.log(str.substr(0,(num-3)) + "...");
		} 
		else 
		{
			console.log(str.substr(0, num) + "...");
		}
		  
		} else console.log(str);
	
	} 

truncateString("A-tisket a-tasket A green and yellow basket", "A-tisket a-tasket A green and yellow basket".length);


Write a function that splits an array (first argument) into groups the length of size (second argument) and returns them as a two-dimensional array.


 var test1 = [2,30,1,2,3];
 var test2 = [3,20,4,5,6];
 var test3 = [];

 test3[0] = test1;
 test3[1] = test2;
 console.log(test3);

console.log(test1.slice(1,3)); //excludes ending



function chunkArrayInGroups(arr, size) {
  var resArr = [];
  var x = 0;

  while (x<arr.length) {
  	resArr.push(arr.slice(x,x+size));
  	x += size;
  }
console.log(resArr);
}

chunkArrayInGroups(["a", "b", "c", "d"], 2);







var myFish = ['angel', 'clown', 'mandarin', 'sturgeon'];

myFish.splice(2, 0, 'drum'); // insert 'drum' at 2-index position
// myFish is ["angel", "clown", "drum", "mandarin", "sturgeon"]

myFish.splice(2, 1); // remove 1 item at 2-index position (that is, "drum")
// myFish is ["angel", "clown", "mandarin", "sturgeon"]


Return the remaining elements of an array after chopping off n elements from the head.

The head means the beginning of the array, or the zeroth index.



//var animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];

//console.log(animals.slice(2));
// expected output: Array ["camel", "duck", "elephant"]

function slasher(arr, howMany) {
 
  console.log(arr.slice(howMany));
}

slasher([1, 2, 3], 9);



//str.toLowerCase();
//str.indexOf("x");


var x = "something";
console.log(x.indexOf("z")) //-1



function mutation(arr) {
 
//var a = arr[0].toString().toLowerCase();
//var b = arr[1].toString().toLowerCase();
var x=0;
var y="";
var result = "";

while (x<arr[1].length) 
{
	y=arr[1][x].toLowerCase();

	if (arr[0].toLowerCase().indexOf(y) == -1)
	{
		result += "1";
	} 
	else
		result += "";
	x++;
}
console.log(result);
	if (result.indexOf(1)>=0) 
	
	console.log("false");
 else
	console.log("true");
}


mutation(["Mary", "Aarmy"]); //true

//mutation(["zyxwvutsrqponmlkjihgfedcba", "QRstu"]);


function mutation(arr) {
  var test = arr[1].toLowerCase();
  var target = arr[0].toLowerCase();
  for (i=0;i<test.length;i++) {
    if (target.indexOf(test[i]) === -1)
      return false;
  }
  return true;
 }




Remove all falsy values from an array.

Falsy values in JavaScript are false, null, 0, "", undefined, and NaN.



//Boolean Objects
//Array.prototype.filter()

function bouncer(arr) {
  // Don't show a false ID to this bouncer.
	
	function fil(val) 
	{
		return Boolean(val) === true;
	};

 console.log(arr.filter(fil));

}

bouncer([7, "ate", "", false, 9]);



Arguments object
Array.prototype.filter()


function destroyer(arr) {
  // Remove all the values

//console.log(arguments.length); //3
//console.log(arguments[0]);
//console.log(arguments[1]);
//console.log(arguments[2]);
var temp = [];

for (var x=1;x<arguments.length;x++) 
{
temp.push(arguments[x]);
}


function fltr(val) 
{
	return (!temp.includes(val));
};

  console.log(arr.filter(fltr));
}

destroyer([1, 2, 3, 1, 2, 3],2, 3);


Return the lowest index at which a value (second argument) should be inserted into an array (first argument) once it has been sorted. The returned value should be a number.

For example, getIndexToIns([1,2,3,4], 1.5) should return 1 because it is greater than 1 (index 0), but less than 2 (index 1).

Likewise, getIndexToIns([20,3,5], 19) should return 2 because once the array has been sorted it will look like [3,5,20] and 19 is less than 20 (index 2) and greater than 5 (index 1).


function getIndexToIns(arr, num) {
  // Find my place in this sorted array.
   //console.log(arr.sort());
   arrS = arr.sort((a, b) => a - b); //sorting numbered arrays
   result = 0;

      for (var x=0; x<arr.length;x++) 
   {
  	if (num > arr[x])
   {
   	console.log(arr);
   	result = x+1;
   } 

 }

    if (arr[arr.length-1] < num )
   	{
   	 result = arr.length;
   	}


 	console.log(result);
}

getIndexToIns([5, 3, 20, 3], 5); //2, 3 3 5 20
getIndexToIns([10, 20, 30, 40, 50], 35); //3
//getIndexToIns([2, 5, 10], 15); //3




One of the simplest and most widely known ciphers is a Caesar cipher, also known as a shift cipher. In a shift cipher the meanings of the letters are shifted by some set amount.

A common modern use is the ROT13 cipher, where the values of the letters are shifted by 13 places. Thus 'A' ↔ 'N', 'B' ↔ 'O' and so on.

Write a function which takes a ROT13 encoded string as input and returns a decoded string.

All letters will be uppercase. Do not transform any non-alphabetic character (i.e. spaces, punctuation), but do pass them on.

  console.log("A".charCodeAt(0));
  console.log("B".charCodeAt(0));
  console.log("C".charCodeAt(0));
  console.log(String.fromCharCode(68)); //D

  	console.log("A".charCodeAt(0));
   	console.log("Z".charCodeAt(0)); 	
A - 65
Z - 90

  for (x=65;x<91;x++) {
  	console.log(x + " " + String.fromCharCode(x));
  }


function rot13(str) { // LBH QVQ VG!
  
  var newStr = "";
  var num = 0;

  for (var x=0;x<str.length;x++) 
  {

  	if (str[x].charCodeAt(0)<65 || str[x].charCodeAt(0)>90)
  	{
  		num = String.fromCharCode((str[x].charCodeAt(0)));
  	}
	else if (str[x].charCodeAt(0)<=77)
	{
	num = String.fromCharCode((str[x].charCodeAt(0))+13);
	} else if (str[x].charCodeAt(0)>77)
	{
	num = String.fromCharCode((str[x].charCodeAt(0))-13);
	}
	newStr += num;
  }
  
  console.log(newStr);
}

// Change the inputs below to test
rot13("SERR PBQR PNZC");

*/

//Bubble sort


// function bubbleSort(arr) {

// 	var first = 0;
// 	var second = 0;

// for (var y=0;y<arr.length;y++) {

// 	for (var x=0; x<arr.length-y;x++) {

// 		first = arr[x];
// 		second = arr[x+1];
	
// 		if (first>second) {
// 			arr[x] = second;
// 			arr[x+1] = first;
// 		} 
// 	}
// }

// 	console.log(arr);
// }

// console.log([3,4,1,5,6,2,7,66,55,14,88,67,9], "original");
// bubbleSort([3,4,1,5,6,2,7,66,55,14,88,67,9]);



// function sumAll(arr) {
// 	var min = Math.min(arr[0],arr[1]);
// 	var max = Math.max(arr[0],arr[1]);
// 	var array = [];

// 	for (var i=min;i<=max;i++) {
// 		array.push(i);
// 	}
// 	console.log(array.reduce((total, added) => total + added));

// }
// sumAll([2, 1]);

// Comparison Operators
// Array.prototype.slice()
// Array.prototype.filter()
// Array.prototype.indexOf()
// Array.prototype.concat()

// function diffArray(arr1, arr2) {
//   var newArr = [];
//   // var length1 = arr1.length;
// 	// var length2 = arr2.length;
//   // console.log(length1 + " " + length2) ;

// arr1.forEach(element => {
// 	if (arr2.indexOf(element) == -1) {
// 		newArr.push(element);
// };

// });

// arr2.forEach(element => {
// 	if (arr1.indexOf(element) == -1) {
// 		newArr.push(element);
// };

// });


// console.log(newArr);
// }

// diffArray([1, 2, 3, 5], [1, 2, 3, 4, 5]);


// CODECAMP Roman Numeral Converter 


// Roman Numerals
// Array.prototype.splice()
// Array.prototype.indexOf()
// Array.prototype.join()

function convertToRoman(num) {
	console.log(num);
};

convertToRoman(12);


</script>

</html>